Framework:
==========
		Ready Made
		
		invasive			->struts
		non-invasive		->spring-->spring boot,hibernate

JSE ,jee,jme


		web-->servlets,ejb,,,...


1	implements Servlet
2	extends GenericServlet
3	extends	HttpServlet-->12
		doGet,doPost

EJB,struts

1*12

100*12=1200
			heavy weight
			light weight
			
class login extends HttpServlet(12)
{
12 methods

}
ROD JOHNSON-->heavy weight 
EJB--->
	interface21
	Spring-->2003


spring is a non-invasive framework,which is used to create light weight and loosley coupled application

	loosley coupled /tightly coupled

class
object-->


class Person{

	Person(String name){
	
	}
	test
}

class Employee{
public void m1(){
	Person person=//has-a
	person.test();
}

}

SPRING-->Dependency Injection 6.x

framework--->jar


Employee	,x,y,z		--->configuration file-->config.XML	--->		IOC
				SpringContainer-->BeanFactory,ApplicationContext-->Object Life Cycle
client


			1)creation of Object
			2)wiring of object
			3)configuring 
			4)destroying


dependency injection
IOC--->inversion of control 

maven-->POM



		java-->jars 

			1)spring core/IOC module/dependency injection
			2)spring JDBC
			3)spring JPA
			4)spring AOP
			5)spring MVC
			6)spring Cloud
			7)spring ai
			8)spring security
			9)spring rest
			...
			
			
	Spring Core 
		setter injection 
		constructor injection			configuration-->xml,annoation....
		
						setterinjection
		autowiring	-->	byname,bytype,constructor	
								field injection
		
						setter injection 
		
			Scope
				singleton
				prototype
				
				request
				session
				application
			
		
		qualifier and count
			
			
			xml--><bean>    Product,Category
			annoation--->@Component,@Autowired,@Configuration,@ComponentScan
							@Scope 
							@Qualifier
							@Bean
							
		NOTE:spring has given annotations @component for only user defined classes 
		@Bean--->datasource,transaction,EntityManager
		
				xml--><bean>,annotation,java
		@Component
		Employee--	X
		
		
		actuators-->beans
		
		@Component,@Service,@Repository,@Controller,@RestController,@Configuration
		
		@Repository
		DAO	-->Service-->controller
				@Service	@Controller
		
		@Bean
		
		
	person--->mobile-->sim1	-->airtel-->MessageSender
					-->sim2	-->jio
		
		
		
		Database-->MYSQL
		
		sun microsystem -->JDBC
		
		1)create tables
		2)querys		mysql
		3)Exception handling
		
		JPA-->ORM(hibernate,eclipselink,top link,ibatis....)
		specification-->implementation
		
		
				JPA-->hibernate
				
				1)no table creation
				2)no database dependent querys
				3)JPQL-->db independent
				4)cache
		
		number
		int
		
		jdbc
		spring jdbc
		
		
		jpa-->ORM
		
			@Entity
			@Table(name="emp_info")
			class Employee{
				@Id
				@Column(name="eid")
				private int empid;
				private String empName;
				...
				..
				
			
			
			}
		
		persistence.xml
		
		<persistence>
			4 properties DB
			<property>
			3 properties hibernate
			
			
		
		
		
		@Transactional
		
		set()
		
		EntityManager-->persist()-->save()-->
			public void addEmp(Employee emp)
			{
				
			
			}
		
		
		TypedQuery-->ResultSet
		
		
		@onetoone(p,fetchtype-eager,lazy)
		
	JPA
	
	
	EmployeeCrud
	
	EmployeeRepo<-->	EmployeeService	<-->	EmployeeController
														Scanner
		EM						repo					Service
		persist					addEmp					1.addemployee
														DTO
	
	Spring+JPA
		transaction  @bean
		datasource
		persistence.xml-->configuration
		dependencies   -->maven
		server		   -->
		
	Spring boot+JPA	
	
		1)Auto Configuration:most of the commonly used classes already configured by SB
		2)starters:maven dependencies(starter-parent)-->60+spring datajpa
		3)actuators-->rest endpoints  insite
		4)embeded server    web-->tomcat ,exclusions-->
		5)in memory db    h2
		
		
		
		springbootjpa-->
		
		Datajpa	-->Repository Layer
		
			CrudRepository,JpaRepository-->I
		
			findAll-->DSL grammer methods
		
		web-->servlets
			spring MVC-->user-->app
			spring rest
			validations,exception handling
			
			SpringBootRestDatajpaEmployeeManagement
			
			
		Webservices:	application to application
			
										java			   python
				sbi atm card -->  icici atm machine  --->sbi server
			
			
			SP
			RMI
			EJB			-->java<-->java
			
			DCOM	-->.net <-->.net
			RPC		-->c/c++<-->c/c++
			CORBA    interoperable
			
			Webservices:
					SOAP
					REST-->web
				
			
			@GetMapping
			@PostMapping
			@PutMapping
			@deleteMapping
			
			
			
			Validations
			exception handling
			
			1.controller level 
			
			2.Application level
			
			
			@ExceptionHandler()
			public void empNotFound()
			{
			}
			
			validations
			
		Bean validations
		
Microservices:
================		
		
		monolithic architecture
		microservices architecture
		
		
									
		shopping app-->	login
						products      1 lakh
						cart
						order		  10000
						payment
						...
						...
		
		tightly coupled
		
		scalling 
		
		one db/server
		
		technology/framework
		
		size
		
		
	Decompose,devide,split your large application into smaller services
		and later communicate them
		
		
		
			independently developed
			independently scalled
			independently deployable
		
		m1
		
		
		m2
		
		
		m3
		
		communication
				synchronous  --->RestTemplate,Open Feign,webclient
				asynchronous --->kafka,rabbitmq,activemq
	
		
		
		problems 
		
		spring cloud 
			config server,eureka server,api gateway,circuitbreaker
		
				JWT
				
				
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		  
	
		
		
	
	
	
	
	
	
	
	
	
	
	
	
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
			
			
			
			
			
			



















